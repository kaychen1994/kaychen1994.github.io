{"pages":[],"posts":[{"title":"HEXO 怎麼安裝?怎麼換主題?","text":"終於架好部落格了!!! 第一篇就要來記錄安裝 HEXO 的過程 因為報名參加六角舉辦的鼠年鐵人賽寫文馬拉松活動，每個禮拜都會在 Medium 上更新文章。後來看到許多參賽者都是自己架一個部落格寫技術文，也讓我躍躍欲試!所以我就開始摸索 HEXO 部落格架站!! 話不多說，趕快進入正題! 做 HEXO 部落格架站之前需要先安裝兩個工具! git Node.js (Node.js 版本需不低於8.10，建議使用 Node.js 10.0 及以上版本) 安裝 Hexo1npm install -g hexo-cli PC 建議使用 CMD ，我用 powershell 的時候出現很多問題… 開一個 Hexo 資料夾1hexo init xxx 這邊的 xxx 代表你要用的部落格資料夾名稱 移到建立部落格的那個資料夾1cd 資料夾 看資料夾內容1dir 生成 Hexo 產生靜態檔案1hexo g 打開 Hexo Server1hexo s 新增文章1hexo new \"文章標題\" 然後你就可以直接到 資料夾/source /_posts /文章標題.md 中的檔案做文章編輯。 編輯文章之後要記得再啟動 Hexo 以及打開 Hexo Server 新增草稿1hexo new draft \"文章標題\" 生成頁面1hexo new page \"page title\" 怎麼換主題?由於 HEXO 官方搭配的 landscape 主題我不喜歡，所以就決定換一個順眼的! HEXO 提供多款主題，大家可以選擇喜歡的下載來用喔! 附上主題官網 我自己用的主題是 icarus 這款，所以下面的範例也會套用 icarus 主題。 要換主題其實非常簡單，在終端機複製貼上這行 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 下載好主題後，一定要回到資料夾的 _config.yml 這個檔案修改主題名稱，把 theme: landscape 改成 theme: icarus 然後，hexo s 打開 server 查看。 但是我在這個流程跑出錯誤訊息，爬文後發現 icarus 這款主題好像蠻多人有這個問題的。 12ERROR Package cheerio is not installed.ERROR Please install the missing dependencies from the root directory of your Hexo site. 解決方式就是 npm i cheerio -S 安裝後就可以再一次 hexo g 、 hexo s 美麗的主題畫面就會跑出來囉~ (圖片是我在編輯這篇文章才截圖的 XDDD) 下一篇要分享「如何把 HEXO 部落格部屬到 Github pages 上面 ?」ps. 途中遇到很多問題，最後終於搞定了 = = (血淚史!)","link":"/2020/03/20/HEXO%E8%88%87github-pages-%E9%85%8D%E7%BD%AE/"},{"title":"HEXO 如何部屬到 Github pages?","text":"HEXO 資料夾設定好之後，當然希望它能正式上線，這樣才是真正的部落格!你可以透過部屬到 Github pages 上擁有超潮 github.io 域名(XDDD)，當然也可以省下買域名的錢，對我這個小資族來說 CP 值超高 ! 將 HEXO 部屬到 Github 上要先開一個 repository，沒有 Github 帳號的可以先註冊一個，流程很快的。 附上 Github 註冊網址 以下是我不專業的分享，有誤敬請見諒! 接下來就趕緊進入部屬 HEXO 到 Github 上的步驟吧! STEP 1. Ceate a new repository STEP 2. 到 HEXO 網站的資料夾安裝一個插件 1npm install hexo-deployer-git --save STEP 3. 到 _config.yml 檔案的 Deployment 部屬 ps. 這邊的 _config.yml 檔案不是主題資料夾中的 _config.yml 檔案，要用 HEXO 本身的 _config.yml 檔案 1234deploy: type: git repo: https://github.com/xxxxx/xxxxx.github.io.git branch: master type –&gt; 你部屬 HEXO 的模式repo –&gt; 貼上你的 GitHub repository 連結branch –&gt; 填上你的分支 (預設是 master) STEP 4. 生成靜態檔案 1hexo g STEP 5. 部屬到 Github 上 1hexo d (Photo by Christopher Gower on Unsplash) 題外話，我在部屬到 Github 途中發生很多狀況。有出現整個 github pages 頁面空白、CSS 版型跑掉的狀況。 後來瘋狂爬文以及重新上傳十幾次才成功… 爬文後發現問題出在一開始的 repository name 上，原來要跟 owner 名字一樣。然後我自己用的主題 icarus 也在安裝過程出現錯誤，後來爬文後也補安裝 npm i cheerio -S 才成功。 希望這篇不專業的 HEXO 部屬到 Github 上的分享，可以幫助到跟我一樣在安裝過程困擾的人。(應該沒有人跟我一樣錯這麼瞎的問題才對 XDDDD)","link":"/2020/03/21/HEXO%E7%9A%84github-%E9%83%A8%E7%BD%B22/"},{"title":"week01 - 1px 也不差的版型控制術","text":"為了精進自己的切版能力，報名了六角學院推出的網頁切版直播班，這次上課讓我收穫很多，有複習到舊觀念也有增加新知識，以下為第一周上課的筆記。 Emmet老師有建議想要提升切版速度，熟悉 Emmet 很重要，也可以減少打錯字找不到 bug 的狀況出現。 所以本周作業嘗試著全程使用 Emmet 做練習，雖然有些不習慣，但是真的有減少之前常常打錯字的問題。 keybr 英打練習我的 keybr profile 連結 熟練英打也可以提升切版速度，因為有報名 21 天英打鍛鍊武道大會，所以持續都有在練習，也發現每天練 10 分鐘，真的可以積沙成多，每天都有進步一點點。 ps. 除了練英打速度，也可以自訂練習 emmet 語法 區塊與行內元素概念老師把 display: block; 以及 display: inline; 拿出來做複習，加強觀念。 區塊元素的特色會另起一行、滿版、可以設定高度與寬度 補充觀念 :h1、p、ul、li 屬於區塊元素 行內元素特色為並排、不滿版 box-modelQ: 試算 box 的寬度? 12345678.box{ width: 80px; /**/ height: 80px; padding-left: 20px;/**/ padding-right: 20px;/**/ background: black; border: 3px solid yellow;/**/} Ans: 80px + 20px + 20px + 3px + 3px = 126px 但是老師有提到一個神奇語法 1234*{ box-sizing: border-box;}` 加上這段語法， box 寬度變成 80 px，就算加上 padding 、 border 都不會改變原本設定的寬度。 行距設定這個地方是我很容易粗心犯錯的地方，還好老師有再加強觀念一次。 Q1: 試問 p 段落高度為多少? 1234p{ font-size: 20px; line-height: 28px;} Ans: p 段落的高度為 28px Q2: 試問 img 圖片與 p 段落的距離是多少 px ? 12&lt;p&gt; hello world &lt;/p&gt;&lt;img src=\"hello.png\" alt=\"\" /&gt; 12345p{ font-size: 20px; line-height: 28px; margin-bottom: 20px;} Ans: 24px (28px-20px)/2 + 20px 除以 2 是因為 4px 在文字上方的行距，另外 4px 在文字下方的行距 css img 3px在老師還沒講之前，我都不知道 img 預設底部會自動多出 2-3px 的留白，若想解決留白問題可以透過 css 做 display: block; 44px 最適合手指點擊根據 IOS APP Guidelines 最小手指觸控範圍是 44px 新手容易犯的錯避免太多重複型的 css ，可以透過整合 class 讓 code 看起來更乾淨俐落。 Week 01 作業(Photo by Domenico Loia on Unsplash) Week 01 - 作業連結 第一周的履歷作業加強了 timeline 的 css 偽元素寫法，雖然還很不熟練，但是會繼續研究，讓寫法更好。 CSS TimeLine &amp; 偽元素 ( Pseudo Element ) 的關係 本周訓練菜單: 將本週教授內容寫成部落格，以加深程式觀念 自主學習新語法，並寫成筆記 熟悉三個編輯器熱鍵，熱鍵中文表 幾乎全程使用 emmet 來開發 透過 keybr.com 練習英打","link":"/2020/04/13/week01-1px-%E4%B9%9F%E4%B8%8D%E5%B7%AE%E7%9A%84%E7%89%88%E5%9E%8B%E6%8E%A7%E5%88%B6%E8%A1%93/"},{"title":"Week02-Flexbox 網頁排版術","text":"這個禮拜切版直播班的主題是期待已久的 Flex !!! 以前在學 float 跟 flex 都傻傻分不清楚，透過直播班還沒開課之前老師釋出的「Flex 精神時光屋」的教學與練習，幫助我釐清複雜的 Flex ~~ 學會 Flex 真的讓排版更輕鬆，省掉 margin 、 padding 推來推去的麻煩! 這次切版直播班老師帶我們看了很多網頁的範例，透過互動回答也幫助我複習了 flex ，對 flex 的使用也更了解。 Flex 外容器 &amp; 內元件 外容器 container (藍色) 內元件 item (紅色) 口訣1：內元件要有效果，就要在外容器加上 display:flex口訣2：每個 HTML 標籤，能同時擁有內元件跟外容器身份 使用 flex 時候，要下在「父層」也就是外容器。 外容器常用語法 ( 下在外容器 ) 決定軸線：flex-direction 1.row ( 預設，橫排、左到右) 2.row-reverse 3.column (直排) 4.column-reverse 主軸對齊：justify-content 1.flex-start ( 預設 ) 2.center 3.flex-end 4.space-between 5.space-around 6.space-evenly 換行屬性：flex-wrap 1.nowrap 2.wrap ( 換行) 交錯軸對齊：align-item 1.flex-start 2.center 3.flex-end 4.stretch 5.baseline 這次老師帶我們看了很多網站排版範例，其中印象最深刻的就是 Taiwan Can Help 這個網站，設計得真的很有質感! 範例互動中，也更釐清 flex 中還可以有 flex !!! 外容器 container (藍色) 內元件 item (紅色) 內元件+外容器特性 (紫色) flex 中還有 flex 的範例是我之前最容易搞混的地方，這次上課、練習有把這個觀念補起來! 老師補充實務觀念 不要亂加語法買保險 class 命名要語意化 試著用小駝峰寫 class 命名 Week 02 作業Week 02 個人網頁 這次的作業有很多練習 flex 排版的地方，剛好也可以加強練習。 本周訓練菜單: 網頁排版縮排 將本週教授內容寫成部落格，以加深程式觀念 透過 keybr.com 練習英打 小駝峰寫法 命名習慣，盡量採語意設計","link":"/2020/04/18/Week02-Flexbox-%E7%B6%B2%E9%A0%81%E6%8E%92%E7%89%88%E8%A1%93/"},{"title":"css3 flex 筆記","text":"flex 六角線上模擬器 為了要精進自己的切版技術，我報名了六角的網頁切版直播班，這幾天都在惡補 flex 的課程，以下就是我這周在上課做的筆記。 傳統的 float 排版只能左右流動，因此無法應對現在多元的排版方式。Ex:置中、垂直、等距等等。 flex 不只解決這些問題，還比 float 更有彈性，了解 flex 之後就可以做出更多樣化的網頁排版，所以 flex 是現在前端必學的超強大排版方式! flex 特性flex 軸線觀念 主軸是由左至右的，以預設來說起點是 “左邊” 開始排列 (水平) 交錯軸是由上往下的，以預設來說起點是 “上面” 開始排列 (垂直) flex 相關屬性 外層屬性 ( Container 外容器 ) 內層屬性 ( Items 內元件 ) flex 對齊方法 主要是仰賴軸線設定來對齊 Bootstrap 4 flex 方法 以 justify-conctent 來說是 主軸 的排列方式 (平行於「主軸」的對齊方式，可以對齊主軸的起點、終點、等距排列 ) 以 align-items 來說是 交錯軸 的排列方式 (可以對齊「交錯軸」的起點、終點、置中 ) 以 flex-direction 來說，它可以改變主軸的方向性，可以改成 垂直 的方向 (由上而下、由下而上)，這個時候排列順序也會做改變 重要的 flex 屬性display: flex; 特性Flex 的好處之一就是會依照外層屬性做比例伸縮，不用怕內層下過大的高度、寬度就會爆出外層，它會自己自適應。 內層屬性預設是等高的，如果都不寫，就會依照最高的做伸縮。也可以自己設定高度(寫死高度還是會依照你的設定做客製化 )，整體來說，Flex 是非常靈活的。 外層屬性：這些都是下在外層( 父層 )上，才能操控內層屬性 display : 必備屬性 flex-direction : 決定 flex 主軸線方向性 justify-conctent : 主要軸線的對齊 align-items : 交錯軸線的對齊 內層屬性 order : 排序 align-self : 單一個物件的交錯軸對齊 主軸會關係到裡面的 item 如何做排列 !主軸的預設排列方向是 左 (主軸起點) –&gt; 右 (主軸終點)那麼主軸除了左到右的排列，還有哪些排版呢?透過主軸來改變 item 的排列方式 flex-direction (決定 flex 主軸線方向性) 外層 flex-direction : row (default) 預設 左–&gt;右 flex-direction : row-reverse 右–&gt;左 flex-direction : column 上–&gt;下 flex-direction : column-reverse 下–&gt;上 justify-conctent (主要軸線的對齊) 外層下圖的範例是以 主軸( flex-direction : row ) 左–&gt;右的情況下使用主軸對齊 依據主軸的軸線決定物件之間的間隔方法 justify-content: flex-start 往主軸線的起點開始 justify-content: flex-end 往主軸線的終點開始 justify-content: space-between 貼齊容器起點跟終點 ( 可以刪掉 padding 跟 margin 來看 ) justify-content: space-around 平均分配留白部分 justify-content: center 是針對主軸來做置中對齊並非水平置中 align-items (交錯軸線的對齊) 外層是垂直於主軸的對齊方法 (所有元件的對其方式)與 align-self 不同 下圖的範例是以 主軸( flex-direction : row ) 左–&gt;右的情況下使用交錯軸對齊 align-self (交錯軸線的對齊) 內層align-self 是「內元件本身」垂直於主軸的對齊方法 不會影響到其他設定值，只管內元件本身 怎麼讓排版斷行?還有一個常用的語法為 flex-wrap: wrap; ，可以幫助排版斷行。 See the Pen flex 選單 by chen (@fatchi20150808) on CodePen. flex 裡面還可以有 flex !!! See the Pen Flex 裡面還可以有 Flex by chen (@fatchi20150808) on CodePen.","link":"/2020/07/30/css-flex/"},{"title":"Vue Cli 上傳 Github pages 路徑部屬問題","text":"在根目錄新創建 vue.config.js 檔案以及deploy.sh 檔案 GitHub Pages 手動推送更新 1. 新增 vue.config.js 檔案12345module.exports = { publicPath: process.env.NODE_ENV === 'production' ? '/你的 repository 名稱/' : '/'} 2. 新增 deploy.sh 檔案12345678910111213141516171819#!/usr/bin/env sh# abort on errorsset -e# buildnpm run build# navigate into the build output directorycd dist# if you are deploying to a custom domain# echo 'www.example.com' &gt; CNAMEgit initgit add -Agit commit -m 'deploy'# if you are deploying to https://&lt;USERNAME&gt;.github.io# git push -f git@github.com:&lt;USERNAME&gt;/&lt;USERNAME&gt;.github.io.git master# if you are deploying to https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;# git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master:gh-pagesgit push -f https://github.com/&lt;你的USERNAME&gt;/&lt;你的 repository&gt;.git master:gh-pages# if you are deploying to https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;# git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master:gh-pages 在終端機輸入 (windows 使用 git bash )1sh deploy.sh 成功部屬","link":"/2020/08/05/vue-cli-github-pages/"},{"title":"怎麼讓 vue-loading-overlay 更改樣式?","text":"vue-loading-overlay 套件 npm vue-loading-overlaycdn vue-loading-overlay loading 樣式 loading.io 因為使用 codepen 練習，所以使用 cdn 來載入 vue-loading-overlay 套件。 JS 1https://cdn.jsdelivr.net/npm/vue-loading-overlay@3.4.0/dist/vue-loading.min.js CSS 1https://cdn.jsdelivr.net/npm/vue-loading-overlay@3.3.2/dist/vue-loading.css 註冊元件 1Vue.component('loading', VueLoading); Use as Component 1&lt;loading :active.sync=&quot;isLoading&quot;&gt;&lt;/loading&gt; 開啟 loading 12345678910// 全域註冊元件Vue.component('loading', VueLoading);new Vue({ el: '#app', data:{ // 預設 : 開啟 loading isLoading: true, },}); 預設 Loading DEMO See the Pen Loading-DEMO by chen (@fatchi20150808) on CodePen. 加入樣式與方法 樣式可以到 loading.io 選擇 選一個喜歡的 loading 樣式，在 download 那邊按下 CSS 複製裡面的內容 樣式包進 loading 元件內12345678910&lt;loading :active.sync=&quot;isLoading&quot;&gt;&lt;!-- 樣式包進 loading 元件內 --&gt; &lt;div class=&quot;loadingio-spinner-ripple-wu44vrvts1&quot;&gt; &lt;div class=&quot;ldio-2gn8nvj94zp&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- 樣式包進 loading 元件內 --&gt; &lt;/loading&gt; 樣式的 CSS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@keyframes ldio-2gn8nvj94zp { 0% { top: 96px; left: 96px; width: 0; height: 0; opacity: 1; } 100% { top: 18px; left: 18px; width: 156px; height: 156px; opacity: 0; }}.ldio-2gn8nvj94zp div { position: absolute; border-width: 4px; border-style: solid; opacity: 1; border-radius: 50%; animation: ldio-2gn8nvj94zp 1s cubic-bezier(0,0.2,0.8,1) infinite;}.ldio-2gn8nvj94zp div:nth-child(1) { border-color: #1d3f72}.ldio-2gn8nvj94zp div:nth-child(2) { border-color: #5699d2; animation-delay: -0.5s;}.loadingio-spinner-ripple-wu44vrvts1 { width: 200px; height: 200px; display: inline-block; overflow: hidden;/* background 設定 none */ background: none;}.ldio-2gn8nvj94zp { width: 100%; height: 100%; position: relative; transform: translateZ(0) scale(1); backface-visibility: hidden; transform-origin: 0 0; /* see note above */}.ldio-2gn8nvj94zp div { box-sizing: content-box; }/* generated by https://loading.io/ */ 方法 按下 Click Me 按鈕後啟動 loading ，並在 7 秒後結束 12345678910111213141516171819Vue.component('loading', VueLoading);new Vue({ el: '#app', data:{ // 預設 : 關閉 loading isLoading: false, }, methods:{ clickMe() { // click 按鈕後開啟 loading this.isLoading = true; setTimeout(() =&gt; { // 7 秒後結束 loading this.isLoading = false; },7000); } }}); Loading 更改樣式 DEMO See the Pen VueLoading by chen (@fatchi20150808) on CodePen.","link":"/2020/08/30/vue-loading/"},{"title":"js-this","text":"MDN this 文件 this 指向123456789this 的指向為何var obj = { name: '小明', fn: function(params) { console.log(params, this, window, arguments); }}obj.fn(1, 2, 3); // 這邊 this 指向 obj simple call 注意：this 的指向相當複雜，大部分情境(95%)只需要了解其中一種即可 傳統函式中的 this 只與調用方式有關 123456var someone = '全域';function callSomeone() { console.log(this.someone);}callSomeone(); // 全域 呼叫 callSomeone 時前方沒有物件，屬於 simple call ，simple call 指向全域 應用變化1. 在呼叫函式時，如果前面有任何一個物件，那麼 this 就會指向前一個物件 obj，因此 console.log 的結果就是物件而非全域。 2. 在呼叫 callSomeone 前有 obj2 這個物件， this 指向 obj2 ，因此 console.log 的結果就是物件2而非全域。 3. 在呼叫 callSomeone 時，前一個物件是 innerObj ， this 指向 innerObj，因此 console.log 的結果就是內層物件而非外層物件、全域。 4. 調用 callSomeone 時，前方沒有物件，屬於 simple call，因此 console.log 的結果就是全域。 5.12345678910111213141516var someone = '全域';function callSomeone() { console.log(this.someone);}var obj4 = { someone: '物件 4', fn() { // callback funtion setTimeout(function () { console.log(this.someone); }); }}obj4.fn(); // 全域 callback funtion 大部分來說屬於 simple call 形式，因此 console.log 的結果就是全域。","link":"/2021/03/19/js-this/"}],"tags":[{"name":"HEXO","slug":"HEXO","link":"/tags/HEXO/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"切版","slug":"切版","link":"/tags/%E5%88%87%E7%89%88/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"flex","slug":"flex","link":"/tags/flex/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Component","slug":"Component","link":"/tags/Component/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"}],"categories":[{"name":"HEXO","slug":"HEXO","link":"/categories/HEXO/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}