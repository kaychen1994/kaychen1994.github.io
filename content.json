{"pages":[],"posts":[{"title":"HEXO 怎麼安裝?怎麼換主題?","text":"終於架好部落格了!!! 第一篇就要來記錄安裝 HEXO 的過程 因為報名參加六角舉辦的鼠年鐵人賽寫文馬拉松活動，每個禮拜都會在 Medium 上更新文章。後來看到許多參賽者都是自己架一個部落格寫技術文，也讓我躍躍欲試!所以我就開始摸索 HEXO 部落格架站!! 話不多說，趕快進入正題! 做 HEXO 部落格架站之前需要先安裝兩個工具! git Node.js (Node.js 版本需不低於8.10，建議使用 Node.js 10.0 及以上版本) 安裝 Hexo1npm install -g hexo-cli PC 建議使用 CMD ，我用 powershell 的時候出現很多問題… 開一個 Hexo 資料夾1hexo init xxx 這邊的 xxx 代表你要用的部落格資料夾名稱 移到建立部落格的那個資料夾1cd 資料夾 看資料夾內容1dir 生成 Hexo 產生靜態檔案1hexo g 打開 Hexo Server1hexo s 新增文章1hexo new \"文章標題\" 然後你就可以直接到 資料夾/source /_posts /文章標題.md 中的檔案做文章編輯。 編輯文章之後要記得再啟動 Hexo 以及打開 Hexo Server 新增草稿1hexo new draft \"文章標題\" 生成頁面1hexo new page \"page title\" 怎麼換主題?由於 HEXO 官方搭配的 landscape 主題我不喜歡，所以就決定換一個順眼的! HEXO 提供多款主題，大家可以選擇喜歡的下載來用喔! 附上主題官網 我自己用的主題是 icarus 這款，所以下面的範例也會套用 icarus 主題。 要換主題其實非常簡單，在終端機複製貼上這行 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 下載好主題後，一定要回到資料夾的 _config.yml 這個檔案修改主題名稱，把 theme: landscape 改成 theme: icarus 然後，hexo s 打開 server 查看。 但是我在這個流程跑出錯誤訊息，爬文後發現 icarus 這款主題好像蠻多人有這個問題的。 12ERROR Package cheerio is not installed.ERROR Please install the missing dependencies from the root directory of your Hexo site. 解決方式就是 npm i cheerio -S 安裝後就可以再一次 hexo g 、 hexo s 美麗的主題畫面就會跑出來囉~ (圖片是我在編輯這篇文章才截圖的 XDDD) 下一篇要分享「如何把 HEXO 部落格部屬到 Github pages 上面 ?」ps. 途中遇到很多問題，最後終於搞定了 = = (血淚史!)","link":"/2020/03/20/HEXO%E8%88%87github-pages-%E9%85%8D%E7%BD%AE/"},{"title":"HEXO 如何部屬到 Github pages?","text":"HEXO 資料夾設定好之後，當然希望它能正式上線，這樣才是真正的部落格!你可以透過部屬到 Github pages 上擁有超潮 github.io 域名(XDDD)，當然也可以省下買域名的錢，對我這個小資族來說 CP 值超高 ! 將 HEXO 部屬到 Github 上要先開一個 repository，沒有 Github 帳號的可以先註冊一個，流程很快的。 附上 Github 註冊網址 以下是我不專業的分享，有誤敬請見諒! 接下來就趕緊進入部屬 HEXO 到 Github 上的步驟吧! STEP 1. Ceate a new repository STEP 2. 到 HEXO 網站的資料夾安裝一個插件 1npm install hexo-deployer-git --save STEP 3. 到 _config.yml 檔案的 Deployment 部屬 ps. 這邊的 _config.yml 檔案不是主題資料夾中的 _config.yml 檔案，要用 HEXO 本身的 _config.yml 檔案 1234deploy: type: git repo: https://github.com/xxxxx/xxxxx.github.io.git branch: master type –&gt; 你部屬 HEXO 的模式repo –&gt; 貼上你的 GitHub repository 連結branch –&gt; 填上你的分支 (預設是 master) STEP 4. 生成靜態檔案 1hexo g STEP 5. 部屬到 Github 上 1hexo d (Photo by Christopher Gower on Unsplash) 題外話，我在部屬到 Github 途中發生很多狀況。有出現整個 github pages 頁面空白、CSS 版型跑掉的狀況。 後來瘋狂爬文以及重新上傳十幾次才成功… 爬文後發現問題出在一開始的 repository name 上，原來要跟 owner 名字一樣。然後我自己用的主題 icarus 也在安裝過程出現錯誤，後來爬文後也補安裝 npm i cheerio -S 才成功。 希望這篇不專業的 HEXO 部屬到 Github 上的分享，可以幫助到跟我一樣在安裝過程困擾的人。(應該沒有人跟我一樣錯這麼瞎的問題才對 XDDDD)","link":"/2020/03/21/HEXO%E7%9A%84github-%E9%83%A8%E7%BD%B22/"},{"title":"week01 - 1px 也不差的版型控制術","text":"為了精進自己的切版能力，報名了六角學院推出的網頁切版直播班，這次上課讓我收穫很多，有複習到舊觀念也有增加新知識，以下為第一周上課的筆記。 Emmet老師有建議想要提升切版速度，熟悉 Emmet 很重要，也可以減少打錯字找不到 bug 的狀況出現。 所以本周作業嘗試著全程使用 Emmet 做練習，雖然有些不習慣，但是真的有減少之前常常打錯字的問題。 keybr 英打練習我的 keybr profile 連結 熟練英打也可以提升切版速度，因為有報名 21 天英打鍛鍊武道大會，所以持續都有在練習，也發現每天練 10 分鐘，真的可以積沙成多，每天都有進步一點點。 ps. 除了練英打速度，也可以自訂練習 emmet 語法 區塊與行內元素概念老師把 display: block; 以及 display: inline; 拿出來做複習，加強觀念。 區塊元素的特色會另起一行、滿版、可以設定高度與寬度 補充觀念 :h1、p、ul、li 屬於區塊元素 行內元素特色為並排、不滿版 box-modelQ: 試算 box 的寬度? 12345678.box{ width: 80px; /**/ height: 80px; padding-left: 20px;/**/ padding-right: 20px;/**/ background: black; border: 3px solid yellow;/**/} Ans: 80px + 20px + 20px + 3px + 3px = 126px 但是老師有提到一個神奇語法 1234*{ box-sizing: border-box;}` 加上這段語法， box 寬度變成 80 px，就算加上 padding 、 border 都不會改變原本設定的寬度。 行距設定這個地方是我很容易粗心犯錯的地方，還好老師有再加強觀念一次。 Q1: 試問 p 段落高度為多少? 1234p{ font-size: 20px; line-height: 28px;} Ans: p 段落的高度為 28px Q2: 試問 img 圖片與 p 段落的距離是多少 px ? 12&lt;p&gt; hello world &lt;/p&gt;&lt;img src=\"hello.png\" alt=\"\" /&gt; 12345p{ font-size: 20px; line-height: 28px; margin-bottom: 20px;} Ans: 24px (28px-20px)/2 + 20px 除以 2 是因為 4px 在文字上方的行距，另外 4px 在文字下方的行距 css img 3px在老師還沒講之前，我都不知道 img 預設底部會自動多出 2-3px 的留白，若想解決留白問題可以透過 css 做 display: block; 44px 最適合手指點擊根據 IOS APP Guidelines 最小手指觸控範圍是 44px 新手容易犯的錯避免太多重複型的 css ，可以透過整合 class 讓 code 看起來更乾淨俐落。 Week 01 作業(Photo by Domenico Loia on Unsplash) Week 01 - 作業連結 第一周的履歷作業加強了 timeline 的 css 偽元素寫法，雖然還很不熟練，但是會繼續研究，讓寫法更好。 CSS TimeLine &amp; 偽元素 ( Pseudo Element ) 的關係 本周訓練菜單: 將本週教授內容寫成部落格，以加深程式觀念 自主學習新語法，並寫成筆記 熟悉三個編輯器熱鍵，熱鍵中文表 幾乎全程使用 emmet 來開發 透過 keybr.com 練習英打","link":"/2020/04/13/week01-1px-%E4%B9%9F%E4%B8%8D%E5%B7%AE%E7%9A%84%E7%89%88%E5%9E%8B%E6%8E%A7%E5%88%B6%E8%A1%93/"},{"title":"Week02-Flexbox 網頁排版術","text":"這個禮拜切版直播班的主題是期待已久的 Flex !!! 以前在學 float 跟 flex 都傻傻分不清楚，透過直播班還沒開課之前老師釋出的「Flex 精神時光屋」的教學與練習，幫助我釐清複雜的 Flex ~~ 學會 Flex 真的讓排版更輕鬆，省掉 margin 、 padding 推來推去的麻煩! 這次切版直播班老師帶我們看了很多網頁的範例，透過互動回答也幫助我複習了 flex ，對 flex 的使用也更了解。 Flex 外容器 &amp; 內元件 外容器 container (藍色) 內元件 item (紅色) 口訣1：內元件要有效果，就要在外容器加上 display:flex口訣2：每個 HTML 標籤，能同時擁有內元件跟外容器身份 使用 flex 時候，要下在「父層」也就是外容器。 外容器常用語法 ( 下在外容器 ) 決定軸線：flex-direction 1.row ( 預設，橫排、左到右) 2.row-reverse 3.column (直排) 4.column-reverse 主軸對齊：justify-content 1.flex-start ( 預設 ) 2.center 3.flex-end 4.space-between 5.space-around 6.space-evenly 換行屬性：flex-wrap 1.nowrap 2.wrap ( 換行) 交錯軸對齊：align-item 1.flex-start 2.center 3.flex-end 4.stretch 5.baseline 這次老師帶我們看了很多網站排版範例，其中印象最深刻的就是 Taiwan Can Help 這個網站，設計得真的很有質感! 範例互動中，也更釐清 flex 中還可以有 flex !!! 外容器 container (藍色) 內元件 item (紅色) 內元件+外容器特性 (紫色) flex 中還有 flex 的範例是我之前最容易搞混的地方，這次上課、練習有把這個觀念補起來! 老師補充實務觀念 不要亂加語法買保險 class 命名要語意化 試著用小駝峰寫 class 命名 Week 02 作業Week 02 個人網頁 這次的作業有很多練習 flex 排版的地方，剛好也可以加強練習。 本周訓練菜單: 網頁排版縮排 將本週教授內容寫成部落格，以加深程式觀念 透過 keybr.com 練習英打 小駝峰寫法 命名習慣，盡量採語意設計","link":"/2020/04/18/Week02-Flexbox-%E7%B6%B2%E9%A0%81%E6%8E%92%E7%89%88%E8%A1%93/"},{"title":"css3 flex 筆記","text":"flex 六角線上模擬器 為了要精進自己的切版技術，我報名了六角的網頁切版直播班，這幾天都在惡補 flex 的課程，以下就是我這周在上課做的筆記。 傳統的 float 排版只能左右流動，因此無法應對現在多元的排版方式。Ex:置中、垂直、等距等等。 flex 不只解決這些問題，還比 float 更有彈性，了解 flex 之後就可以做出更多樣化的網頁排版，所以 flex 是現在前端必學的超強大排版方式! flex 特性flex 軸線觀念 主軸是由左至右的，以預設來說起點是 “左邊” 開始排列 (水平) 交錯軸是由上往下的，以預設來說起點是 “上面” 開始排列 (垂直) flex 相關屬性 外層屬性 ( Container 外容器 ) 內層屬性 ( Items 內元件 ) flex 對齊方法 主要是仰賴軸線設定來對齊 Bootstrap 4 flex 方法 以 justify-conctent 來說是 主軸 的排列方式 (平行於「主軸」的對齊方式，可以對齊主軸的起點、終點、等距排列 ) 以 align-items 來說是 交錯軸 的排列方式 (可以對齊「交錯軸」的起點、終點、置中 ) 以 flex-direction 來說，它可以改變主軸的方向性，可以改成 垂直 的方向 (由上而下、由下而上)，這個時候排列順序也會做改變 重要的 flex 屬性display: flex; 特性Flex 的好處之一就是會依照外層屬性做比例伸縮，不用怕內層下過大的高度、寬度就會爆出外層，它會自己自適應。 內層屬性預設是等高的，如果都不寫，就會依照最高的做伸縮。也可以自己設定高度(寫死高度還是會依照你的設定做客製化 )，整體來說，Flex 是非常靈活的。 外層屬性：這些都是下在外層( 父層 )上，才能操控內層屬性 display : 必備屬性 flex-direction : 決定 flex 主軸線方向性 justify-conctent : 主要軸線的對齊 align-items : 交錯軸線的對齊 內層屬性 order : 排序 align-self : 單一個物件的交錯軸對齊 主軸會關係到裡面的 item 如何做排列 !主軸的預設排列方向是 左 (主軸起點) –&gt; 右 (主軸終點)那麼主軸除了左到右的排列，還有哪些排版呢?透過主軸來改變 item 的排列方式 flex-direction (決定 flex 主軸線方向性) 外層 flex-direction : row (default) 預設 左–&gt;右 flex-direction : row-reverse 右–&gt;左 flex-direction : column 上–&gt;下 flex-direction : column-reverse 下–&gt;上 justify-conctent (主要軸線的對齊) 外層下圖的範例是以 主軸( flex-direction : row ) 左–&gt;右的情況下使用主軸對齊 依據主軸的軸線決定物件之間的間隔方法 justify-content: flex-start 往主軸線的起點開始 justify-content: flex-end 往主軸線的終點開始 justify-content: space-between 貼齊容器起點跟終點 ( 可以刪掉 padding 跟 margin 來看 ) justify-content: space-around 平均分配留白部分 justify-content: center 是針對主軸來做置中對齊並非水平置中 align-items (交錯軸線的對齊) 外層是垂直於主軸的對齊方法 (所有元件的對其方式)與 align-self 不同 下圖的範例是以 主軸( flex-direction : row ) 左–&gt;右的情況下使用交錯軸對齊 align-self (交錯軸線的對齊) 內層align-self 是「內元件本身」垂直於主軸的對齊方法 不會影響到其他設定值，只管內元件本身 怎麼讓排版斷行?還有一個常用的語法為 flex-wrap: wrap; ，可以幫助排版斷行。 See the Pen flex 選單 by chen (@fatchi20150808) on CodePen. flex 裡面還可以有 flex !!! See the Pen Flex 裡面還可以有 Flex by chen (@fatchi20150808) on CodePen.","link":"/2020/07/30/css-flex/"},{"title":"Vue Cli 上傳 Github pages 路徑部屬問題","text":"在根目錄新創建 vue.config.js 檔案以及deploy.sh 檔案 GitHub Pages 手動推送更新 1. 新增 vue.config.js 檔案12345module.exports = { publicPath: process.env.NODE_ENV === 'production' ? '/你的 repository 名稱/' : '/'} 2. 新增 deploy.sh 檔案12345678910111213141516171819#!/usr/bin/env sh# abort on errorsset -e# buildnpm run build# navigate into the build output directorycd dist# if you are deploying to a custom domain# echo 'www.example.com' &gt; CNAMEgit initgit add -Agit commit -m 'deploy'# if you are deploying to https://&lt;USERNAME&gt;.github.io# git push -f git@github.com:&lt;USERNAME&gt;/&lt;USERNAME&gt;.github.io.git master# if you are deploying to https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;# git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master:gh-pagesgit push -f https://github.com/&lt;你的USERNAME&gt;/&lt;你的 repository&gt;.git master:gh-pages# if you are deploying to https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;# git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master:gh-pages 在終端機輸入 (windows 使用 git bash )1sh deploy.sh 成功部屬","link":"/2020/08/05/vue-cli-github-pages/"},{"title":"怎麼讓 vue-loading-overlay 更改樣式?","text":"vue-loading-overlay 套件 npm vue-loading-overlaycdn vue-loading-overlay loading 樣式 loading.io 因為使用 codepen 練習，所以使用 cdn 來載入 vue-loading-overlay 套件。 JS 1https://cdn.jsdelivr.net/npm/vue-loading-overlay@3.4.0/dist/vue-loading.min.js CSS 1https://cdn.jsdelivr.net/npm/vue-loading-overlay@3.3.2/dist/vue-loading.css 註冊元件 1Vue.component('loading', VueLoading); Use as Component 1&lt;loading :active.sync=&quot;isLoading&quot;&gt;&lt;/loading&gt; 開啟 loading 12345678910// 全域註冊元件Vue.component('loading', VueLoading);new Vue({ el: '#app', data:{ // 預設 : 開啟 loading isLoading: true, },}); 預設 Loading DEMO See the Pen Loading-DEMO by chen (@fatchi20150808) on CodePen. 加入樣式與方法 樣式可以到 loading.io 選擇 選一個喜歡的 loading 樣式，在 download 那邊按下 CSS 複製裡面的內容 樣式包進 loading 元件內12345678910&lt;loading :active.sync=&quot;isLoading&quot;&gt;&lt;!-- 樣式包進 loading 元件內 --&gt; &lt;div class=&quot;loadingio-spinner-ripple-wu44vrvts1&quot;&gt; &lt;div class=&quot;ldio-2gn8nvj94zp&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- 樣式包進 loading 元件內 --&gt; &lt;/loading&gt; 樣式的 CSS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@keyframes ldio-2gn8nvj94zp { 0% { top: 96px; left: 96px; width: 0; height: 0; opacity: 1; } 100% { top: 18px; left: 18px; width: 156px; height: 156px; opacity: 0; }}.ldio-2gn8nvj94zp div { position: absolute; border-width: 4px; border-style: solid; opacity: 1; border-radius: 50%; animation: ldio-2gn8nvj94zp 1s cubic-bezier(0,0.2,0.8,1) infinite;}.ldio-2gn8nvj94zp div:nth-child(1) { border-color: #1d3f72}.ldio-2gn8nvj94zp div:nth-child(2) { border-color: #5699d2; animation-delay: -0.5s;}.loadingio-spinner-ripple-wu44vrvts1 { width: 200px; height: 200px; display: inline-block; overflow: hidden;/* background 設定 none */ background: none;}.ldio-2gn8nvj94zp { width: 100%; height: 100%; position: relative; transform: translateZ(0) scale(1); backface-visibility: hidden; transform-origin: 0 0; /* see note above */}.ldio-2gn8nvj94zp div { box-sizing: content-box; }/* generated by https://loading.io/ */ 方法 按下 Click Me 按鈕後啟動 loading ，並在 7 秒後結束 12345678910111213141516171819Vue.component('loading', VueLoading);new Vue({ el: '#app', data:{ // 預設 : 關閉 loading isLoading: false, }, methods:{ clickMe() { // click 按鈕後開啟 loading this.isLoading = true; setTimeout(() =&gt; { // 7 秒後結束 loading this.isLoading = false; },7000); } }}); Loading 更改樣式 DEMO See the Pen VueLoading by chen (@fatchi20150808) on CodePen.","link":"/2020/08/30/vue-loading/"},{"title":"JS 觀念 - this 指向","text":"MDN this 文件 this 指向123456789this 的指向為何var obj = { name: '小明', fn: function(params) { console.log(params, this, window, arguments); }}obj.fn(1, 2, 3); // 這邊 this 指向 obj simple call 注意：this 的指向相當複雜，大部分情境(95%)只需要了解其中一種即可 傳統函式中的 this 只與調用方式有關 123456var someone = '全域';function callSomeone() { console.log(this.someone);}callSomeone(); // 全域 呼叫 callSomeone 時前方沒有物件，屬於 simple call ，simple call 指向全域 應用變化1. 在呼叫函式時，如果前面有任何一個物件，那麼 this 就會指向前一個物件 obj，因此 console.log 的結果就是物件而非全域。 2. 在呼叫 callSomeone 前有 obj2 這個物件， this 指向 obj2 ，因此 console.log 的結果就是物件2而非全域。 3. 在呼叫 callSomeone 時，前一個物件是 innerObj ， this 指向 innerObj，因此 console.log 的結果就是內層物件而非外層物件、全域。 4. 調用 callSomeone 時，前方沒有物件，屬於 simple call，因此 console.log 的結果就是全域。 5.12345678910111213141516var someone = '全域';function callSomeone() { console.log(this.someone);}var obj4 = { someone: '物件 4', fn() { // callback funtion setTimeout(function () { console.log(this.someone); }); }}obj4.fn(); // 全域 callback funtion 大部分來說屬於 simple call 形式，因此 console.log 的結果就是全域。","link":"/2021/03/19/js-this/"},{"title":"JS 觀念 - ES6 縮寫","text":"什麼是語法糖?語法糖讓程式更加簡潔，有更高的可讀性。語法糖不會影響程式運作，邏輯與當前 JS 一致。 物件字面值 Object literals 物件內的函式 12345678const apple = { name: '蘋果', fn: function() { return this.name; }}console.log(apple.fn()); 直接將 fn: function() {} 改為 fn() {} 即可 物件內的變數 123456789const person = { name: '阿肥'};const people = { person: person};console.log(people); 當名稱跟值同名，可以省略名稱。直接將 person: person 縮寫為 person 即可 展開 不同陣列合併 123456const groupA = ['阿肥', '小胖', '大摳呆'];const groupB = ['蘋果', '香蕉'];const groupAll = groupA.concat(groupB);console.log(groupAll); 直接使用…展開即可，const groupAll = [...groupA, ...groupB] 物件擴展 新增一個物件包含新方法，同時加入原有的方法 1234567891011121314151617181920const methods = { fn1() { console.log(1); }, fn2() { console.log(1); },}const newMethods = { fn() { console.log(1); }, ...methods // 加入原有的方法 // 使用 ... 也可以展開 function}console.log(newMethods); 轉成純陣列 12345&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; 12const doms = document.querySelectorAll('li');console.log(doms); 雖然 querySelectorAll 會取到所有 li ，但並非純陣列 (類陣列) 將類陣列使用 … 可以轉為純陣列 (純陣列) 預設值1234567function sum(a, b) { return a + b;}console.log(sum(1));// sun(1) 只有帶入一筆資料，會顯示 NaN 如果有預設值，當資料找不到時，就會套用預設值若資料有正常傳入就不會套用預設值 123456function sum(a, b = 5) { return a + b;}console.log(sum(1)); // 6 ，資料找不到 ，直接套用預設值 5console.log(sum(1,3)) // 4 ，料有正常傳入，不會套用預設值","link":"/2021/03/19/js-es6/"},{"title":"JS 觀念 - 箭頭函式的 this 指向差異","text":"MDN 箭頭函式文件 傳統函式與箭頭函式寫法差別傳統函式取有餘數的值（單數） 1234567const arr = [1, 2, 3, 4, 5];const filterArr = arr.filter(function(item) { return item % 2 // 只要結果為真值就會回傳})console.log(filterArr); // [ 1,3,5 ] 箭頭函式取有餘數的值（單數） 12const filterArr = arr.filter(item =&gt; item % 2);console.log(filterArr); 箭頭函式可以將 function 移除掉改成箭頭，接著把 {} 、 return 移除掉，改成單行。箭頭函式它會自動帶上 return當參數只有一個時，可以把 () 拿掉，當參數有 2 個或沒有參數則不可省略 箭頭函式與傳統函式的 this 指向有何差別?傳統函式123456789101112var name = '全域'const person = { name: '小胖', callName: function () { console.log('1', this.name); // 1 小胖 setTimeout(function () { console.log('2', this.name); // 2 simple call 指向全域的 name console.log('3', this); // 3 指向 window }, 10); },}person.callName(); 箭頭函式 箭頭函式沒有自己的 this 123456789101112var name = '全域'const person = { name: '小胖', callName: function () { console.log('1', this.name); // 1 小胖 setTimeout(()=&gt; { console.log('2', this.name); // 2 小胖 console.log('3', this); // 3 指向 person 物件 }, 10); },}person.callName(); 如果 setTimeout function 採箭頭函式，那麼 this 就要往外層的 callName function 看。外層的 callName function 的 this 指向哪裡，那麼內層 setTimeout function 的 this 就指向哪裡。 箭頭函式陷阱1. 12345678var name = '全域'const person = { name: '小胖', callName: () =&gt; { console.log(this.name); },}person.callName(); // 全域 因為 callName function 找不到外層函式，所以指向全域 2. 1234567891011var name = '全域'const person = { name: '小胖', callMe() { const callName = () =&gt; { console.log(this.name); }; callName(); }}person.callMe(); callName function 的外層函式是 callMe，callMe 的 this 指向 person ，this.name = 小胖 常見用法123456789101112var someone = '全域';var obj4 = { someone: '物件 4', fn() { setTimeout(function () { console.log(this.someone); }); }}obj4.fn(); 如何讓 setTimeout function 取得 obj4 中的 someone ?方法 1. this 先指向其他變數 12345678910111213var someone = '全域';var obj4 = { someone: '物件 4', fn() { const vm = this; setTimeout(function () { console.log(vm.someone); // 確保取得 obj4 物件，不受干擾 }); }}obj4.fn(); 方法 2. 使用箭頭函式，讓 this 去找外層的 123456789101112var someone = '全域';var obj4 = { someone: '物件 4', fn() { setTimeout(()=&gt; { // 改成箭頭函式 console.log(this.someone); }); }}obj4.fn();","link":"/2021/03/21/js-arrow-function/"},{"title":"JS 觀念 - 物件傳參考特性、淺拷貝、深拷貝","text":"物件傳參考 物件是以傳參考的形式賦值 12345678910const person = { name: '小胖', obj: {}}const person2 = person;person2.name = '阿肥';console.log(person); 因為物件傳參考的特性(記憶體位置指向一樣)，導致最後都在改同一個物件資料。 console 結果為： person 中的小胖 改成了 阿肥 2. 1234567891011const fn = (item) =&gt; { item.name = 'Jack'; // ...}const person = { name: 'Alan', obj: {}}fn(person);console.log(person); console 結果為： person 中的Alan 改成了 Jack 物件傳參考問題：我們在開發時，可能創下許多變數，卻因為物件傳參考的特性(記憶體位置指向一樣)，導致最後都在改同一個物件資料、修改到原始資料。 解決物件傳參考問題淺拷貝方法1. 使用 Object.assign()。 MDN 文件 12345678const person = { name: '小明', obj: {}}const person2 = Object.assign({}, person);console.log(person === person2); // false 方法2. 使用 ... 展開。 MDN 文件 1234567891011const person = { name: '小明', obj: {}}const person3 = { ...person}console.log(person === person3); // false 淺拷貝也會遇到問題!!!淺拷貝可以新建立記憶體空間，再把 person 內容複製過來。因為是淺層拷貝，所以第二層的 obj 物件還是指向原本的 obj，並沒有新建立記憶體空間，修改 person2 / person3 的 obj 還是會影響到原有 person 的 obj。 12345678910111213const person = { name: '小明', obj: {}}const person2 = Object.assign({}, person);console.log(person === person2); // falseperson2.obj.age = 15;console.log(person, person2) console.log(person, person2) 的結果為： 深拷貝可以解決淺拷貝第二層物件傳參考的問題。 深拷貝 透過物件先轉為字串，再將字串轉為物件達到深拷貝。 物件轉字串方法 JSON.stringify() - MDN 字串轉物件方法 JSON.parse() - MDN 1234567891011121314const person = { name: '小明', obj: {}}// 深層拷貝讓 person 與 person2 兩者完全無關係。const person2 = JSON.parse(JSON.stringify(person));console.log(person === person2); // falseperson2.obj.age = 15;console.log(person, person2); console.log(person, person2) 結果為： person2 第二層物件修改內容也不會影響到 person 的第二層物件，因為兩個物件完全無關係。","link":"/2021/03/22/Shallow-Copy-vs-Deep-Copy/"},{"title":"JS 觀念 - Promise 非同步","text":"Promise 物件代表一個即將完成、或失敗的非同步操作，以及它所產生的值。 Promise - MDN 使用 Promise - MDN 非同步觀念非同步行為會在所有程式碼執行完後才執行，因此看到非同步行為，執行順序就放最後。 就算 setTimeout 設定 0 秒，一樣不會改變它最後執行的順序。 1234567891011121314function getData() { setTimeout(() =&gt; { console.log('... 已取得遠端資料'); }, 0);}// 請問取得資料的順序為何const component = { init() { console.log(1); // 順序 1 getData(); // 順序 3 console.log(2); // 順序 2 }}component.init(); consle 結果 : 12312... 已取得遠端資料' 而 Promise 是為了解決傳統非同步語法難以建構及管理的問題。 Promise1234567891011const promiseSetTimeout = (status) =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { if (status) { resolve('promiseSetTimeout 成功') } else { reject('promiseSetTimeout 失敗') } }, 0); })} Promise 基礎應用1234promiseSetTimeout(true) .then(res =&gt; { console.log(res); }) consle 結果 : 1promiseSetTimeout 成功 Promise 串接12345678promiseSetTimeout(true) .then(res =&gt; { console.log(1, res); return promiseSetTimeout(true) }) .then(res =&gt; { console.log(2, res); }) consle 結果 : 121 &quot;promiseSetTimeout 成功&quot;2 &quot;promiseSetTimeout 成功&quot; Promise 失敗捕捉promiseSetTimeout 成功的話跑 then ，失敗的話跑 catch 1234567promiseSetTimeout(false) .then(res =&gt; { console.log(res); }) .catch(err =&gt; { console.log(err); }) consle 結果 : 1promiseSetTimeout 失敗 Promise 元件運用把非同步資料寫回 data 12345678910111213const component = { data: {}, init() { promiseSetTimeout(true) .then(res =&gt; { this.data.res = res; // 非同步資料寫回 data console.log(this); console.log(this.data.res); }) }}component.init(); consle 結果 : 使用 axios 套件串接遠端 API axios 練習 API 成功接收練習成功跑 then 1234567axios.get('https://randomuser.me/api/') .then(res =&gt; { console.log(res.data.results); }) .catch(err =&gt; { console.log(err.response); }) consle 結果 : 失敗接收練習失敗跑 catch 1234567axios.get('https://randomuser.me/api/err') // 錯誤的 API .then(res =&gt; { console.log(res.data.results); }) .catch(err =&gt; { console.log(err.response); // err.response 才能顯示失敗內容 }) consle 結果 :","link":"/2021/03/23/js-promise/"},{"title":"git 學習資源 & 基礎指令","text":"安裝windowsMac OSX 參考資源 Git、GitHub 教學 - 六角學院 Git &amp; GitHub 教學手冊 - 六角學院 為你自己學 Git - 高見龍 30 天精通 Git 版本控管 - Will 保哥 基本 command 指令 移動路徑：cd 路徑 回上一層：cd .. 展開列表：ls 開新資料夾： mkdir 資料夾名稱 開新檔案： touch 檔案名稱 ps. window CMD 無法使用展開列表、開新檔案，但在 git bash 上可以。 git 常用指令 初始化數據庫1git init 將檔案加入索引1git add . 將索引檔案提交1git commit -m \"xxx\" 更新遠端數據庫1git push origin master 下載遠端數據庫1git clone 數據庫網址 查看目前狀態1git status 查看歷史紀錄1git log","link":"/2021/03/28/git-learning/"},{"title":"gitignore 忽略檔案","text":"gitignore如果有些檔案不想進入版本控制，就可以使用 gitignore 來忽略檔案。 新增.gitignore 檔案在.gitignore 檔案中可以寫入不想進入版本控制的檔案。 範例： 在.gitignore 檔案中寫進 index2.html、ignore.css，這兩個檔案就不會進入版本控制，也不會被 push 到 github 上。 在 github 的數據庫看不到 index2.html、ignore.css 這兩個檔案 ↓ 如果想要讓整個 css 資料夾或是全部 html 檔案都忽略，可以用下方的寫法 ↓ 12css/*.html 哪些檔案可以不用進入版控？以 Sass 為範例 gitignore 範例文件 在gitignore 範例文件中，可以找到Sass.gitignore這隻檔案。 可以看到css.map、sass.map、scss.map檔案以及sass-cache 資料夾是不用進入版控的。 當 sass 編譯成 css 時，會把一些暫存歷史紀錄放入sass-cache 資料夾，裡面內容不重要。而css.map、sass.map、scss.map屬於 source map 檔案，所以全部 .map 檔案不需要進入版控。","link":"/2021/03/29/git-gitignore/"},{"title":"git push 到 github & Github Pages 筆記","text":"會用到的 Git 常用指令將檔案加入索引1git add . 將索引檔案提交1git commit -m \"xxx\" 更新遠端數據庫1git push origin master 下載遠端數據庫1git clone 數據庫網址 流程 DEMO 連結 Github 開新數據庫先到 github 新增 repository 將數據庫 Git clone 下來到本地數據庫先在桌面開一個資料夾，打開 git bash 將 github 的數據庫 clone 下來。 12cd 資料夾git clone 網址 進入 clone 下來的資料夾1cd 剛剛 clone 下來的資料夾 新增檔案在 clone 下來的資料夾新增檔案。 加入索引1git add . 將索引檔案提交1git commit -m \"XXX\" XXX 那邊可以隨意打，版本號/更新內容/修改內容… 建立分支1git branch -M main 推上 github1git push -u origin main 範例 Demo範例：新增 index.html ，然後 commit 提交( 第一次 commit ) 之後又在 index.html 中新增兩行 code ，然後 commit 提交( 第二次 commit ) 紅色圈起來的地方就是輸入 XXX 的內容 右上角會顯示 commit 次數 (commit 次數包含 Initial commit) 點進去後會顯示 ↓ 按紅色圈起來的按鈕就可以看見推上 github 的修改歷史與新增內容 ↓ Github Pages GitHub_Pages - wiki 免費用來做靜態網站的好工具，用來架自己的部落格非常方便。簡單幾個指令就可以生成靜態網站，免費的雄讚!!! 點選 settings ↓ 往下滑，找到 Github Pages 設定，勾選 main ，然後儲存 ↓ 畫面更新後，回到 Github Pages 設定位置，上方會顯示 Github Pages 連結 Github Pages 網頁產生https://kaychen1994.github.io/Git-Demo/","link":"/2021/03/30/git-push-n-github-pages/"},{"title":"Vuex 基本核心概念筆記 [01]","text":"Vuex 文件 什麼是 Vuex ? 用來管理前端網頁資料狀態，適合用來開發大型專案。可以方便做為元件之間資料的共享，是實現元件全域狀態管理的一種機制。 Vuex 屬於單向資料流 使用 Vuex 統一做資料管理的好處 能夠集中管理共享的資料，在開發與維護上會更方便。 實現元件與元件之間的資料共享，開發上會更有效率。 存在 Vuex 的資料是響應式的，可以保持頁面與資料自動同步。 什麼時候要將資料存到 Vuex 當中? 一般來說，如果元件之間有資料需要共享時就可以將資料存到 Vuex。若資料不需要共享，存在元件中的 data 即可。不過可以根據開發需要做調整。 安裝 Vuex安裝npm install vuex --save import 1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) 創建 Store123456const store = new Vuex.Store({ // state 放全域共享資料 state: { count: 0 }}) 最後將 Store 掛載在 Vue 的實體中 1234new Vue({ el: '#app', store: store,}) 嚴格模式開發中，開啟嚴格模式，無論何時發生了狀態變更且不是由 mutation 函數引起的，將會拋出錯誤。這能保證所有的狀態變更都能被調試工具跟踪到。 123const store = new Vuex.Store({ strict: true})","link":"/2021/04/05/vuex-01/"}],"tags":[{"name":"HEXO","slug":"HEXO","link":"/tags/HEXO/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"切版","slug":"切版","link":"/tags/%E5%88%87%E7%89%88/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"flex","slug":"flex","link":"/tags/flex/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Component","slug":"Component","link":"/tags/Component/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"axios","slug":"axios","link":"/tags/axios/"},{"name":"github pages","slug":"github-pages","link":"/tags/github-pages/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"}],"categories":[{"name":"HEXO","slug":"HEXO","link":"/categories/HEXO/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"git","slug":"git","link":"/categories/git/"}]}